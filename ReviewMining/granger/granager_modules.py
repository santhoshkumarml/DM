# Autogenerated with SMOP version 0.1.1
# main.py ../mat/*.m
from __future__ import division
def granger_anomaly_detection(time_series=None,lag=None,ref_indices=None,test_indices=None,slide_times=None,alpha=None,
                              lambda=None, lambda1=None,lambda2=None,NC=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 10-[time_series,lag,ref_indices,test_indices,slide_times,alpha,lambda_,lambda1,lambda2,NC].count(None)+len(args)
    ref_series=time_series[:,ref_indices]
    ref_coeffs,__=ts_lasso_regression(ref_series,lag, lambda_,nargout=2)
    p,T1= size(ref_series,nargout=2)
    anomaly_threshs=zeros(p,1)
    window_size=len(test_indices)
    for i in arange(1,p).reshape(-1):
        sigma1=sqrt(var(ref_series[i,:]))
        ref_anomaly_scores=zeros(1,T1 - window_size + 1)
        for start in arange(1,T1 - window_size + 1).reshape(-1):
            cur_ref_series=ref_series[:,start:start + window_size - 1]
            sigma2=sqrt(var(cur_ref_series[i,:]))
            ref_anomaly_scores[start]=max(myAnomalyScore(sigma1,sigma2,0,0),myAnomalyScore(sigma2,sigma1,0,0))
        para=expfit(ref_anomaly_scores)
        anomaly_threshs[i]=expinv(alpha,para)
    test_coeffs=cell(p,slide_times + 1)
    anomaly_scores=zeros(p,slide_times + 1)

    for off_set in arange(0,slide_times).reshape(-1):
        test_series=time_series[:,test_indices + off_set]
        temp,X_test=ts_lasso_ref_regression(test_series,lag,lambda1,ref_coeffs,lambda2,NC,nargout=2)
        for i in arange(1,p).reshape(-1):
            test_coeffs[i,off_set + 1]=temp[i]
        cur_anomaly_scores=zeros(p,1)
        for i in arange(1,p).reshape(-1):
            delta=mean(X_test).T
            coeffs=reshape(ref_coeffs[i].T,[],1)
            mu1=coeffs.T * delta
            coeffs=reshape(test_coeffs[i,off_set + 1].T,[],1)
            mu2=coeffs.T * delta
            sigma1=sqrt(var(ref_series[i,:]))
            sigma2=sqrt(var(test_series[i,:]))
            cur_anomaly_scores[i]=max(myAnomalyScore(sigma1,sigma2,mu1,mu2),myAnomalyScore(sigma2,sigma1,mu2,mu1))
            anomaly_scores[i,off_set + 1]=cur_anomaly_scores[i]
    return ref_coeffs,test_coeffs,anomaly_scores,anomaly_threshs
def ts_lasso_regression(series=None,lag=None,lambda=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 3-[series,lag,lambda_].count(None)+len(args)

    p,T=size(series,nargout=2)
    coeffs=cell(p,1)
    D=p * lag
    N=T - lag
    PHI=zeros(N,D)
    t=zeros(N,1)
    for i in arange(1,N).reshape(-1):
        for j in arange(1,p).reshape(-1):
            cur_row_start=(j - 1) * lag + 1
            cur_row_end=cur_row_start + lag - 1
            PHI[i,cur_row_start:cur_row_end]=series[j,i:(i + lag - 1)]
    for target_row in arange(1,p).reshape(-1):
        t[1:N,1]=series[target_row,(lag + 1):(lag + N)].T
        b_opt,__,__=LassoShooting(PHI,t,lambda_,nargout=3)
        disp(char('After Lasso Shooting'))
        coeffs[target_row]=vec2mat(b_opt,lag)
    return coeffs,PHI
def ts_lasso_ref_regression(series=None,lag=None,lambda1=None,ref_coeffs=None,lambda2=None,NC=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[series,lag,lambda1,ref_coeffs,lambda2,NC].count(None)+len(args)

    p,T=size(series,nargout=2)
    coeffs=cell(p,1)
    D=p * lag
    N=T - lag
    PHI=zeros(N,D)
    t=zeros(N,1)
    for i in arange(1,N).reshape(-1):
        for j in arange(1,p).reshape(-1):
            cur_row_start=(j - 1) * lag + 1
            cur_row_end=cur_row_start + lag - 1
            PHI[i,cur_row_start:cur_row_end]=series[j,i:(i + lag - 1)]
    for target_row in arange(1,p).reshape(-1):
        t[1:N,1]=series[target_row,(lag + 1):(lag + N)].T
        cur_ref_coeffs=reshape(ref_coeffs[target_row].T,[],1)
        if NC == 1:
            zero_indices=find(cur_ref_coeffs == 0).T
            nonzero_indices=find(cur_ref_coeffs != 0).T
            b_opt,__,__=Lasso2LambdaShooting(PHI,t,lambda1,lambda2,zero_indices,nonzero_indices,nargout=3)
        else:
            b_opt,__,__=myLassoRefShooting(PHI,t,lambda1,cur_ref_coeffs,lambda2,nargout=3)
        coeffs[target_row]=vec2mat(b_opt,lag)
    return coeffs,PHI
def granger_stoc_anomaly_detection(time_series=None,lag=None,ref_indices=None,test_indices=None,slide_times=None,alpha=None,lambda=None,lambda1=None,method=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 9-[time_series,lag,ref_indices,test_indices,slide_times,alpha,lambda_,lambda1,method].count(None)+len(args)

    disp(char('training...'))
    ref_series=time_series[:,ref_indices]
    ref_coeffs,__=ts_lasso_regression(ref_series,lag,lambda_,method,nargout=2)
    p,T1=size(ref_series,nargout=2)
    anomaly_threshs=zeros(p,1)
    window_size=length(test_indices)
    ref_anomaly_scores=zeros(52,T1 - window_size + 1)
    for start in arange(1,T1 - window_size + 1).reshape(-1):
        if mod(start,100) == 0:
            fprintf(char('sliding in ref data: #%d\n'),start)
        cur_ref_series=ref_series[:,start:start + window_size - 1]
        cur_ref_coeffs,cur_PHI=ts_lasso_ref_regression(cur_ref_series,lag,lambda1,ref_coeffs,method,nargout=2)
        for i in arange(1,p).reshape(-1):
            mu1=reshape(ref_coeffs[i].T,[],1).T * mean(cur_PHI).T
            mu2=reshape(cur_ref_coeffs[i].T,[],1).T * mean(cur_PHI).T
            sigma1=sqrt(var(ref_series[i,:]))
            sigma2=sqrt(var(cur_ref_series[i,:]))
            ref_anomaly_scores[i,start]=max(myAnomalyScore(sigma1,sigma2,mu1,mu2),myAnomalyScore(sigma2,sigma1,mu2,mu1))
    for i in arange(1,p).reshape(-1):
        para=expfit(ref_anomaly_scores[i,:])
        anomaly_threshs[i]=expinv(alpha,para)
    disp(char('testing...'))
    test_coeffs=cell(p,slide_times + 1)
    anomaly_scores=zeros(p,slide_times + 1)
    for off_set in arange(0,slide_times).reshape(-1):
        if mod(off_set + 1,100) == 0:
            disp(cat(char('sliding in test data: #'),num2str(off_set + 1)))
        test_series=time_series[:,test_indices + off_set]
        temp,X_test=ts_lasso_ref_regression(test_series,lag,lambda1,ref_coeffs,method,nargout=2)
        for i in arange(1,p).reshape(-1):
            test_coeffs[i,off_set + 1]=temp[i]
        cur_anomaly_scores=zeros(p,1)
        for i in arange(1,p).reshape(-1):
            delta=mean(X_test).T
            coeffs=reshape(ref_coeffs[i].T,[],1)
            mu1=coeffs.T * delta
            coeffs=reshape(test_coeffs[i,off_set + 1].T,[],1)
            mu2=coeffs.T * delta
            sigma1=sqrt(var(ref_series[i,:]))
            sigma2=sqrt(var(test_series[i,:]))
            cur_anomaly_scores[i]=max(myAnomalyScore(sigma1,sigma2,mu1,mu2),myAnomalyScore(sigma2,sigma1,mu2,mu1))
            anomaly_scores[i,off_set + 1]=cur_anomaly_scores[i]
    return ref_coeffs,test_coeffs,anomaly_scores,anomaly_threshs
def ts_lasso_regression(series=None,lag=None, lambda1=None,method=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 4-[series,lag,lambda_,method].count(None)+len(args)

    p,T=size(series,nargout=2)
    coeffs=cell(p,1)
    D=p * lag
    N=T - lag
    PHI=zeros(N,D)
    t=zeros(N,1)
    for i in arange(1,N).reshape(-1):
        for j in arange(1,p).reshape(-1):
            cur_row_start=(j - 1) * lag + 1
            cur_row_end=cur_row_start + lag - 1
            PHI[i,cur_row_start:cur_row_end]=series[j,i:(i + lag - 1)]
    for target_row in arange(1,p).reshape(-1):
        t[1:N,1]=series[target_row,(lag + 1):(lag + N)].T
        if method == 0:
            b_opt=PStocSubGD(PHI,t,1e-08,lambda_,80,0,0)
        if method == 1:
            b_opt=SCD(PHI,t,lambda_,2,80,0)
        if method == 2:
            b_opt=PSGD_Yahoo(PHI,t,1e-08,lambda_,0)
        if method == 3:
            b_opt=SGLD(PHI,t,1e-15,1000,1,lambda_,10,80,0)
        if method == 4:
            b_opt=shotgun_lasso(PHI,t,lambda_,80,0,8,1e-05,50)
        coeffs[target_row]=vec2mat(b_opt,lag)
    return coeffs,PHI
def ts_lasso_ref_regression(series=None,lag=None,lambda=None,ref_coeffs=None,method=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 5-[series,lag,lambda_,ref_coeffs,method].count(None)+len(args)

    p,T=size(series,nargout=2)
    coeffs=cell(p,1)
    D=p * lag
    N=T - lag
    PHI=zeros(N,D)
    t=zeros(N,1)
    for i in arange(1,N).reshape(-1):
        for j in arange(1,p).reshape(-1):
            cur_row_start=(j - 1) * lag + 1
            cur_row_end=cur_row_start + lag - 1
            PHI[i,cur_row_start:cur_row_end]=series[j,i:(i + lag - 1)]
    for target_row in arange(1,p).reshape(-1):
        t[1:N,1]=series[target_row,(lag + 1):(lag + N)].T
        cur_ref_coeffs=reshape(ref_coeffs[target_row].T,[],1)
        if method == 0:
            b_opt=PStocSubGD_ref(PHI,t,cur_ref_coeffs,1e-10,lambda_,80,0,0)
        if method == 1:
            b_opt=SCD_ref(PHI,t,cur_ref_coeffs,lambda_,2,80,0)
        if method == 2:
            b_opt=PSGD_Yahoo_ref(PHI,t,cur_ref_coeffs,1e-08,lambda_,0)
        if method == 3:
            b_opt=SGLD_ref(PHI,t,cur_ref_coeffs,1e-10,1,0.1,lambda_,10,80,0)
            b_opt[b_opt < 0.0001]=0
        if method == 4:
            b_opt=shotgun_lasso_ref(PHI,t,cur_ref_coeffs,lambda_,80,0,8,1e-05,50)
        coeffs[target_row]=vec2mat(b_opt,lag)
    return coeffs,PHI
def Lasso2LambdaShooting(X=None,y=None,lambda_1=None,lambda_2=None,indices_1=None,indices_2=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[X,y,lambda_1,lambda_2,indices_1,indices_2].count(None)+len(args)

    maxIter,verbose,optTol,zeroThreshold=process_options(varargin,char('maxIter'),1000,char('verbose'),0,char('optTol'),1e-05,char('zeroThreshold'),0.0001,nargout=4)
    n,p=size(X,nargout=2)
    Diag=eye(p)
    for i in indices_1.reshape(-1):
        Diag[i,i]=lambda_1
    for i in indices_2.reshape(-1):
        Diag[i,i]=lambda_2
    beta=numpy.linalg.solve((X.T * X + Diag),(X.T * y))
    wp=copy(beta)
    if verbose == 2:
        w_old=copy(beta)
        fprintf(char('%10s %10s %15s %15s %15s\n'),char('iter'),char('shoots'),char('n(w)'),char('n(step)'),char('f(w)'))
        k=1
        wp=copy(beta)
    m=0
    XX2=X.T * X * 2
    Xy2=X.T * y * 2
    while m < maxIter:

        beta_old=copy(beta)
        for j in indices_1.reshape(-1):
            S0=sum_(XX2[j,:] * beta) - XX2[j,j] * beta[j] - Xy2[j]
            if S0 > lambda_1:
                beta[j,1]=(lambda_1 - S0) / XX2[j,j]
            else:
                if S0 < - lambda_1:
                    beta[j,1]=(- lambda_1 - S0) / XX2[j,j]
                else:
                    if abs_(S0) <= lambda_1:
                        beta[j,1]=0
        for j in indices_2.reshape(-1):
            S0=sum_(XX2[j,:] * beta) - XX2[j,j] * beta[j] - Xy2[j]
            if S0 > lambda_2:
                beta[j,1]=(lambda_2 - S0) / XX2[j,j]
            else:
                if S0 < - lambda_2:
                    beta[j,1]=(- lambda_2 - S0) / XX2[j,j]
                else:
                    if abs_(S0) <= lambda_2:
                        beta[j,1]=0
        m=m + 1
        if verbose == 2:
            s=0
            for i in indices_1.reshape(-1):
                s=s + lambda_1 * abs_(beta[i])
            for i in indices_2.reshape(-1):
                s=s + lambda_2 * abs_(beta[i])
            fprintf(char('%10d %10d %15.2e %15.2e %15.2e\n'),m,m * p,sum_(abs_(beta)),sum_(abs_(beta - w_old)),sum_((X * beta - y) ** 2) + s)
            w_old=copy(beta)
            k=k + 1
            wp[:,k]=beta
        if sum_(abs_(beta - beta_old)) < optTol:
            break

    if verbose:
        fprintf(char('Number of iterations: %d\nTotal Shoots: %d\n'),m,m * p)
    w=copy(beta)
    return w,wp,m
def myAnomalyScore(sigma1=None,sigma2=None,mu1=None,mu2=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 4-[sigma1,sigma2,mu1,mu2].count(None)+len(args)

    anomaly_score=log(sigma2 / sigma1) - 0.5 * (1 - 1 / (sigma2 ** 2) * (sigma1 ** 2 + (mu1 - mu2) ** 2))
    return anomaly_score
def myLassoRefShooting(X=None,y=None,lambda1=None,ref_w=None,lambda2=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 5-[X,y,lambda1,ref_w,lambda2].count(None)+len(args)

    maxIter,verbose,optTol,zeroThreshold=process_options(varargin,char('maxIter'),1000,char('verbose'),0,char('optTol'),1e-05,char('zeroThreshold'),0.0001,nargout=4)
    n,p=size(X,nargout=2)
    beta=numpy.linalg.solve((X.T * X + lambda1 * eye(p)),(X.T * y))
    wp=copy(beta)
    if verbose == 2:
        w_old=copy(beta)
        fprintf(char('%10s %10s %15s %15s %15s\n'),char('iter'),char('shoots'),char('n(w)'),char('n(step)'),char('f(w)'))
        k=1
        wp=copy(beta)
    m=0
    XX2=X.T * X * 2
    Xy2=X.T * y * 2
    while m < maxIter:

        beta_old=copy(beta)
        for j in arange(1,p).reshape(-1):
            S0=sum_(XX2[j,:] * beta) - XX2[j,j] * beta[j] - Xy2[j]
            if ref_w[j] >= 0:
                slope=XX2[j,j]
                th1=lambda1 + lambda2
                th2=lambda1 - lambda2
                th3=lambda1 - lambda2 - slope * ref_w[j]
                th4=- lambda1 - lambda2 - slope * ref_w[j]
                if S0 > th1:
                    beta[j,1]=(th1 - S0) / slope
                else:
                    if S0 <= th1 and S0 >= th2:
                        beta[j,1]=0
                    else:
                        if S0 < th2 and S0 > th3:
                            beta[j,1]=(th2 - S0) / slope
                        else:
                            if S0 <= th3 and S0 >= th4:
                                beta[j,1]=ref_w[j]
                            else:
                                if S0 < th4:
                                    beta[j,1]=(- lambda1 - lambda2 - S0) / slope
            if ref_w[j] < 0:
                slope=XX2[j,j]
                th1=lambda1 + lambda2 + slope * abs_(ref_w[j])
                th2=lambda2 - lambda1 + slope * abs_(ref_w[j])
                th3=lambda2 - lambda1
                th4=- lambda1 - lambda2
                if S0 > th1:
                    beta[j,1]=(lambda1 + lambda2 - S0) / slope
                else:
                    if S0 <= th1 and S0 >= th2:
                        beta[j,1]=ref_w[j]
                    else:
                        if S0 < th2 and S0 > th3:
                            beta[j,1]=(th3 - S0) / slope
                        else:
                            if S0 <= th3 and S0 >= th4:
                                beta[j,1]=0
                            else:
                                if S0 < th4:
                                    beta[j,1]=(th4 - S0) / slope
        m=m + 1
        if verbose == 2:
            fprintf(char('%10d %10d %15.2e %15.2e %15.2e\n'),m,m * p,sum_(abs_(beta)),sum_(abs_(beta - w_old)),sum_((X * beta - y) ** 2) + lambda1 * sum_(abs_(beta - ref_w)) + lambda2 * sum_(abs_(beta)))
            w_old=copy(beta)
            k=k + 1
            wp[:,k]=beta
        if sum_(abs_(beta - beta_old)) < optTol:
            break

    if verbose:
        fprintf(char('Number of iterations: %d\nTotal Shoots: %d\n'),m,m * p)
    w=copy(beta)
    return w,wp,m