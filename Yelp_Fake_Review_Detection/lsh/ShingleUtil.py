from __future__ import division
'''
Created on Jan 12, 2015

@author: santhosh
'''
import re
import numpy
import sys

skip_words = '[\n]|[ ]|[\t]'

def createAndReturnShingles(texts, n):
    shingle_dict = dict()
    text_index = 0
    for text in texts:
        shingle = ''
        for t in text:
            if t != ' ':
                shingle = shingle+t
            if(len(shingle) == n):
                if shingle not in shingle_dict:
                    shingle_dict[shingle] = numpy.zeros(len(texts))        
                shingle_dict[shingle][text_index] = 1
                shingle = ''
    
        if shingle != '':
            if shingle not in shingle_dict:
                    shingle_dict[shingle] = numpy.zeros(len(texts))
            shingle_dict[shingle][text_index] = 1
            
        text_index+=1
        
    return shingle_dict

def formDataMatrix(texts, n):
    shingle_dict = createAndReturnShingles(texts, n)
    
    n = len(shingle_dict.keys())
    m = len(texts)
    
    data_matrix = numpy.zeros(shape =(n,m))
    shingle_list = []
    
    index = 0
    for key in shingle_dict.keys():
        data_matrix[index] = shingle_dict[key]
        shingle_list.append(key)
        index+=1

    #print shingle_list, data_matrix
    return data_matrix

# Autogenerated with SMOP version 
# main.py /media/santhosh/Data/workspace/datalab/data/src/jac_doc_hash.m

def jac_doc_hash(A,r,b):
    print A
    n,m= A.shape
    s=r*b
    S=numpy.zeros(shape=(s,m))
    M=numpy.zeros(shape=(s,n))
    for i in numpy.arange(0,s).reshape(-1):
        M[i,:]=numpy.random.permutation(numpy.arange(1,n+1))
    print M
    
    for i in numpy.arange(0,m).reshape(-1):
        out = A[:,i]
        index = 0
        if(sum(out) > 0):
            temp_min_for_iter = ''
            for index in range(len(out)):
                if out[index] > 0:
                    print i,M[:,index]
                    if temp_min_for_iter == '':
                        temp_min_for_iter = numpy.array(M[:,index])
                    else:
                        temp_min_for_iter = numpy.vstack((temp_min_for_iter,M[:,index]))
            print temp_min_for_iter.transpose()
            print numpy.amin(temp_min_for_iter,axis=0)
            print '----------------------------------------'
            S[:,i]=numpy.amin(temp_min_for_iter,axis=0)
            #print S

    M = numpy.zeros(shape=(s,n))
    A = numpy.zeros(shape=A.shape)
    
    maps=numpy.zeros(shape=(b,1))
    
    for j in numpy.arange(0,b).reshape(-1):
        from_=1 + r * (j - 1)
        to=from_ + (r - 1)
        c= dict()
        for i in numpy.arange(0,m).reshape(-1):
            t=S[from_:to,i]
            t=str(t)
            if (t in c):
                c[t] = numpy.append(c[t],i)
            else:
                c[t]=numpy.array([i])
        
        print j,c  
        maps[j]= c
        
    S=numpy.zeros(s,m)
    
    candidategroups=numpy.arange(0,m)
    
    for i in numpy.arange(0,b).reshape(-1):
        c=maps[i]
        k=c.keys()
        for j in numpy.arange(1,len(k)).reshape(-1):
            candidategroups[c[k[j]]]=min(candidategroups[c[k[j]]])
            
    ucg=set(candidategroups)
    num_clusters=len(ucg)
    print num_clusters
    return candidategroups
